param(                         
    [switch]$debug = $false,   ## if -debug parameter capture execution in log script 
    [switch]$prompt = $false   ## if -prompt puase for user input
)

<# CIAOPS

Script provided as is. Use at own risk. No guarantees or warranty provided.

Description - Creates new spam policies with best practice settings if they don't exist,
              or modifies existing best practice policies to comply with current best practices.
Documentation - https://github.com/directorcia/patron/wiki/Get-existing-spam-policies-and-comparing-to-best-practices
Source - https://github.com/directorcia/patron/blob/master/o365-mx-spam-get.ps1

Prerequisites = 2
1. Ensure connected to Exchange Online. Use the script https://github.com/directorcia/Office365/blob/master/o365-connect-exo.ps1
2. Ensure connected to Microsoft Graph. The script will attempt to connect for you.

Configuration Options:
- $autoApply = $true|$false - Set to true to automatically apply best practice settings (default: true)
- $DefaultLanguageBlockList - Default languages to block when language block list is empty
- $DefaultRegionBlockList - Default regions to block when region block list is empty

Compatibility - PowerShell 5.1 and higher. PowerShell 7+ recommended.

#>

## Variables
$systemmessagecolor = "cyan"
$processmessagecolor = "green"
$errormessagecolor = "red"
$warningmessagecolor = "yellow"
$pass = "(.)"
$fail = "(X)"
# $debug and $prompt are now parameters
$autoApply = $true # Automatically apply best practice settings
$createPolicy = $true # Create new policy if it doesn't exist

# Tracking variables for policy creation - used in final summary
$quarantinePolicyCreated = $false # Set to true when quarantine policy is created
$malwarePolicyCreated = $false # Set to true when malware policy is created

# Default values for empty language and region block lists
$DefaultLanguageBlockList = @("ZH-CN", "RU", "KO", "JA")  # Simplified Chinese, Russian, Korean, Japanese
$DefaultRegionBlockList = @("CN", "RU", "IR", "KP", "CU")  # China, Russia, Iran, North Korea, Cuba

# Email validation function
function Validate-EmailAddress {
    param (
        [string]$EmailAddress
    )

    $emailRegex = '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    $isValid = $EmailAddress -match $emailRegex

    return $isValid
}

# Error handling function
function HandleError {
    param (
        [Parameter(Mandatory = $true)]
        [string]$ErrorMessage,
        
        [Parameter(Mandatory = $true)]
        [string]$ErrorCode,
        
        [Parameter(Mandatory = $false)]
        [bool]$ExitScript = $true
    )
    
    Write-Host -ForegroundColor $errormessagecolor "[$ErrorCode] - $ErrorMessage`n"
    
    if ($debug) {
        try {
            Stop-Transcript -ErrorAction SilentlyContinue
        }
        catch {
            # Ignore errors stopping transcript
        }
    }
    
    if ($ExitScript) {
        # Instead of exiting, we'll pause and let the user read the error
        Write-Host -ForegroundColor $errormessagecolor "Press any key to continue or Ctrl+C to exit..."
        $host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown") | Out-Null
        return $false
    }
    return $true
}

# Function to safely check if a collection is empty
function IsCollectionEmpty {
    param (
        [Parameter(Mandatory = $false)]
        $Collection
    )
    
    if ($null -eq $Collection) { return $true }
    if ($Collection -is [System.Array]) { return $Collection.Count -eq 0 }
    
    # For other collection types that support Count property
    try {
        return $Collection.Count -eq 0
    }
    catch {
        # For objects that don't support Count, try to iterate
        try {
            return -not ($Collection | Select-Object -First 1)
        }
        catch {
            # If all else fails, assume it's not a collection
            return $false
        }
    }
}

# Function to handle rule management (consolidated to reduce code duplication)
function Manage-SpamFilterRule {
    param (
        [Parameter(Mandatory = $true)]
        [string]$RuleType,  # "Inbound" or "Outbound"
        
        [Parameter(Mandatory = $true)]
        [string]$PolicyName,
        
        [Parameter(Mandatory = $true)]
        [bool]$PolicyExists,
        
        [Parameter(Mandatory = $true)]
        [string]$RuleName,
        
        [Parameter(Mandatory = $false)]
        [bool]$RuleExists = $false,
        
        [Parameter(Mandatory = $false)]
        [object]$ExistingRule = $null,
        
        [Parameter(Mandatory = $false)]
        [array]$Domains = @(),
        
        [Parameter(Mandatory = $true)]
        [bool]$ShouldCreate = $true,
        
        [Parameter(Mandatory = $true)]
        [bool]$AutoApply = $true
    )
    
    Write-Host -ForegroundColor $processmessagecolor "Managing $RuleType spam filter rule for policy: $PolicyName"
    
    # Skip rule creation if policy doesn't exist and we shouldn't create it
    if (-not $PolicyExists -or -not $ShouldCreate) {
        Write-Host -ForegroundColor $processmessagecolor "Policy doesn't exist or creation not requested. Skipping rule creation."
        return $null
    }
    
    # If we have an existing rule, check it
    if ($RuleExists -and $ExistingRule) {
        Write-Host -ForegroundColor $processmessagecolor "Checking existing rule: $($ExistingRule.Name)"
        $ruleUpdateNeeded = $false
        $ruleUpdateParams = @{}
        
        # Check if rule is enabled
        if ($ExistingRule.state -ne "Enabled") {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Rule is not enabled", $fail
            $ruleUpdateParams.Add("State", "Enabled")
            $ruleUpdateNeeded = $true
        } else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Rule is enabled", $pass
        }
        
        # Check priority
        if ($ExistingRule.Priority -ne 0) {
            Write-Host -ForegroundColor $warningmessagecolor "   [FAIL] Priority = ", $ExistingRule.Priority, $fail
            $ruleUpdateParams.Add("Priority", 0)
            $ruleUpdateNeeded = $true
        } else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Priority is set to 0 (highest)", $pass
        }
        
        # Apply updates if needed
        if ($ruleUpdateNeeded -and $AutoApply) {
            try {
                Write-Host -ForegroundColor $processmessagecolor "   Applying updates to $RuleType rule '$($ExistingRule.Name)'..."
                $ruleUpdateParams.Add("Identity", $ExistingRule.Name)
                
                if ($RuleType -eq "Inbound") {
                    Set-HostedContentFilterRule @ruleUpdateParams -ErrorAction Stop
                } else {
                    Set-HostedOutboundSpamFilterRule @ruleUpdateParams -ErrorAction Stop
                }
                
                Write-Host -ForegroundColor $processmessagecolor "   Changes applied successfully to $RuleType rule."
            }
            catch {
                Write-Host -ForegroundColor $errormessagecolor "   [ERROR] Failed to update $RuleType rule: $($_.Exception.Message)"
            }
        }
        elseif ($ruleUpdateNeeded -and -not $AutoApply) {
            Write-Host -ForegroundColor $warningmessagecolor "   Changes required for $RuleType rule but auto-apply is disabled."
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   No changes needed for $RuleType rule."
        }
        
        return $ExistingRule
    }
    
    # If we need to create a new rule
    if (-not $RuleExists) {
        # For outbound rules, check if the policy is default (which doesn't need a rule)
        if ($RuleType -eq "Outbound") {
            $policy = Get-HostedOutboundSpamFilterPolicy -Identity $PolicyName -ErrorAction SilentlyContinue
            if ($policy -and $policy.IsDefault) {
                Write-Host -ForegroundColor $processmessagecolor "Policy '$PolicyName' is the default policy - no rule needed"
                return $null
            }
        }
        
        Write-Host -ForegroundColor $processmessagecolor "Creating new $RuleType spam filter rule: $RuleName"
        
        try {
            if ($RuleType -eq "Inbound") {
                $ruleParams = @{
                    'Name' = $RuleName
                    'HostedContentFilterPolicy' = $PolicyName
                    'Priority' = 0
                    'Enabled' = $true
                }
                
                # Only add domains if we have them
                if ($Domains -and ($Domains | Measure-Object).Count -gt 0) {
                    $ruleParams['RecipientDomainIs'] = $Domains
                }
                
                $newRule = New-HostedContentFilterRule @ruleParams -ErrorAction Stop
            } 
            else { # Outbound
                $ruleParams = @{
                    'Name' = $RuleName
                    'HostedOutboundSpamFilterPolicy' = $PolicyName
                    'Priority' = 0
                    'Enabled' = $true
                }
                
                # Only add domains if we have them
                if ($Domains -and ($Domains | Measure-Object).Count -gt 0) {
                    $ruleParams['SenderDomainIs'] = $Domains
                }
                
                $newRule = New-HostedOutboundSpamFilterRule @ruleParams -ErrorAction Stop
            }
            
            Write-Host -ForegroundColor $processmessagecolor "Successfully created $RuleType spam filter rule: $RuleName"
            return $newRule
        }
        catch {
            Write-Host -ForegroundColor $errormessagecolor "Error creating $RuleType spam filter rule: $($_.Exception.Message)"
            return $null
        }
    }
    
    return $null
}

# Start transcript if debug is enabled
try {
    Clear-Host
    if ($debug) {
        $scriptPath = $MyInvocation.MyCommand.Path
        if ([string]::IsNullOrEmpty($scriptPath)) {
            $scriptPath = $PSCommandPath
        }
        
        if ([string]::IsNullOrEmpty($scriptPath)) {
            $transcriptPath = Join-Path (Get-Location).Path "o365-mx-spam-get.txt"
        }
        else {
            $transcriptPath = Join-Path (Split-Path -Parent $scriptPath) "o365-mx-spam-get.txt"
        }
        
        Start-Transcript -Path $transcriptPath -ErrorAction Stop
        Write-Host -ForegroundColor $processmessagecolor "[Info] = Script activity logged at $transcriptPath`n"
    }
    else {
        Write-Host -ForegroundColor $processmessagecolor "[Info] = Debug mode disabled`n"
    }
}
catch {
    Write-Host -ForegroundColor $errormessagecolor "[001] - Failed to start transcript: $($_.Exception.Message)"
    # Continue execution even if transcript fails
}

Write-Host -ForegroundColor $systemmessagecolor "Start Script - Apply Best Practices to M365 Spam Settings`n"

if ($autoApply) {
    Write-Host -ForegroundColor $processmessagecolor "[Info] = Auto-apply mode enabled - Will automatically apply best practices"
}
else {
    Write-Host -ForegroundColor $processmessagecolor "[Info] = Auto-apply mode disabled - Will only report issues"
}

if ($prompt) {
    Write-Host -ForegroundColor $processmessagecolor "[Info] = Prompt mode enabled"
}
else {
    Write-Host -ForegroundColor $processmessagecolor "[Info] = Prompt mode disabled"
}

# Check PowerShell version
$ps = $PSVersionTable.PSVersion
Write-Host -ForegroundColor $processmessagecolor "`nDetected PowerShell version: $($ps.Major).$($ps.Minor)"

if ($ps.Major -lt 7) {
    Write-Host -ForegroundColor $warningmessagecolor "This script works best with PowerShell version 7 or above. Some features might be limited."
}

# Prompt if enabled
If ($prompt) { 
    try {
        Read-Host -Prompt "`n[PROMPT] -- Press Enter to continue" | Out-Null
    }
    catch {
        HandleError -ErrorMessage "Error during prompt: $($_.Exception.Message)" -ErrorCode "002" -ExitScript $false
    }
}

# Check if we're already connected to Exchange Online
$connectedToExO = $false
try {
    # Try a simple Exchange Online command to test connection
    $null = Get-AcceptedDomain -ErrorAction Stop
    $connectedToExO = $true
    Write-Host -ForegroundColor $processmessagecolor "Already connected to Exchange Online"
}
catch {
    Write-Host -ForegroundColor $warningmessagecolor "Not connected to Exchange Online yet."
}

# Check for Exchange Online module
try {
    if (Get-Module -ListAvailable -Name ExchangeOnlineManagement) {
        Write-Host -ForegroundColor $processmessagecolor "Exchange Online PowerShell module found"
        
        # If not already connected, attempt to connect
        if (-not $connectedToExO) {
            Write-Host -ForegroundColor $processmessagecolor "Attempting to connect to Exchange Online..."
            try {
                Connect-ExchangeOnline -ErrorAction Stop
                Write-Host -ForegroundColor $processmessagecolor "Successfully connected to Exchange Online"
            }
            catch {
                $continue = HandleError -ErrorMessage "Failed to connect to Exchange Online: $($_.Exception.Message). Please connect manually before running this script." -ErrorCode "003B" -ExitScript $false
                if (-not $continue) { return }
            }
        }
    }
    else {
        $continue = HandleError -ErrorMessage "Exchange Online PowerShell module not installed. Please install and re-run script." -ErrorCode "003" -ExitScript $false
        if (-not $continue) { return }
    }
}
catch {
    $continue = HandleError -ErrorMessage "Error checking for Exchange Online module: $($_.Exception.Message)" -ErrorCode "004" -ExitScript $false
    if (-not $continue) { return }
}

# Check for Microsoft Graph module - but make it optional
$graphModuleAvailable = $false
try {
    if (Get-Module -ListAvailable -Name Microsoft.Graph) {    
        Write-Host -ForegroundColor $processmessagecolor "Microsoft Graph PowerShell found"
        $graphModuleAvailable = $true
    }
    else {
        Write-Host -ForegroundColor $warningmessagecolor "Graph PowerShell module not installed. Will continue with limited functionality."
        # Not exiting - we'll handle this gracefully
    }
}
catch {
    Write-Host -ForegroundColor $warningmessagecolor "Error checking for Graph module: $($_.Exception.Message). Will continue with limited functionality."
}

# Only try Graph operations if the module is available
$context = $null
if ($graphModuleAvailable) {
    # Disconnect any existing Graph sessions
    Write-Host -ForegroundColor $processmessagecolor "Disconnecting any existing Graph sessions"
    try {
        Disconnect-MgGraph -ErrorAction SilentlyContinue | Out-Null
    }
    catch {
        # Ignore any errors disconnecting
        Write-Host -ForegroundColor $processmessagecolor "  No active Graph sessions to disconnect"
    }

    # Connect to Microsoft Graph
    Write-Host -ForegroundColor $processmessagecolor "Connecting to Microsoft Graph"
    try {
        Connect-MgGraph -Scopes "Directory.AccessAsUser.All", "Directory.Read.All, Directory.ReadWrite.All, RoleManagement.ReadWrite.Directory" -ErrorAction Stop | Out-Null
        $context = Get-MgContext
        Write-Host -ForegroundColor $processmessagecolor "Connected to Graph as: $($context.Account)"
    }
    catch {
        Write-Host -ForegroundColor $warningmessagecolor "Unable to connect to Microsoft Graph: $($_.Exception.Message). Will continue with limited functionality."
    }
}

# Get Global Administrators for notification
Write-Host -ForegroundColor $processmessagecolor "Getting tenant administrators"

# Initialize email variables
$emailArray = @()
$notifyUsers = @()

# Only try Graph operations if the module is available
if ($graphModuleAvailable -and $context) {
    try {
        $globalAdmins = Get-MgDirectoryRole -ErrorAction Stop | Where-Object { $_.displayName -eq "Global Administrator" }
        $globalAdminUsers = Get-MgDirectoryRoleMember -DirectoryRoleId $globalAdmins.id -ErrorAction Stop

        # Output the list of global administrators
        Write-Host -ForegroundColor $processmessagecolor "List of Global administrators:"
        $globaladminsummary = @()
        foreach ($adminuser in $globalAdminUsers) {
            $user = Get-MgUser -UserId $adminuser.Id -ErrorAction Stop
            $globaladminSummary += [pscustomobject]@{       
                Id                = $adminuser.Id 
                UserPrincipalName = $user.UserPrincipalName
                DisplayName       = $user.DisplayName
            }
            Write-Host -ForegroundColor Gray "  - $($user.DisplayName) ($($user.UserPrincipalName))"
        }

        # Prompt for selection of desired tenant global administrators for notification
        if ($globaladminSummary.Count -gt 0) {
            try {
                $admins = $globaladminSummary | Select-Object DisplayName, UserPrincipalName, Id | Sort-Object DisplayName | Out-GridView -PassThru -Title "Select existing Global admins for notification (Multiple selections permitted)"
                Write-Host -ForegroundColor $processmessagecolor "Global administrators selected for notification: $(($admins | Measure-Object).count)"
                
                # Add the selected Global Admin emails to our notification list
                if ($admins) {
                    $emailArray += $admins.UserPrincipalName
                }
            }
            catch {
                Write-Host -ForegroundColor $warningmessagecolor "Unable to display admin selection UI: $($_.Exception.Message)"
                # Add all admin emails instead
                $emailArray += $globaladminSummary.UserPrincipalName
                Write-Host -ForegroundColor $processmessagecolor "Added all admin emails automatically"
            }
        }
    }
    catch {
        Write-Host -ForegroundColor $warningmessagecolor "Unable to retrieve Global Administrators via Graph: $($_.Exception.Message)"
    }
}
else {
    Write-Host -ForegroundColor $warningmessagecolor "Graph module not available - skipping admin retrieval"
}

# Fallback to Exchange Online to try getting tenant admin if Graph failed
if (($emailArray | Measure-Object).Count -eq 0) {
    try {
        # Try to get admin emails through Exchange Online
        Write-Host -ForegroundColor $processmessagecolor "Attempting to retrieve admin emails through Exchange Online"
        $orgConfig = Get-OrganizationConfig -ErrorAction Stop
        if ($orgConfig.TechnicalNotificationMails) {
            $emailArray += $orgConfig.TechnicalNotificationMails
            Write-Host -ForegroundColor $processmessagecolor "Found $(($orgConfig.TechnicalNotificationMails | Measure-Object).Count) technical notification email(s)"
        }
    }
    catch {
        Write-Host -ForegroundColor $warningmessagecolor "Unable to retrieve admin emails through Exchange Online: $($_.Exception.Message)"
    }
}

# Prompt the user to enter additional email addresses for notifications
Write-Host -ForegroundColor $processmessagecolor "Enter additional email addresses for notifications (press Enter with no input to continue):"
do {
    try {
        $email = Read-Host -Prompt "Enter email address for alerts (ENTER to continue)"
        if ($email -ne "") {
            $email = $email.Trim()

            if (Validate-EmailAddress $email) {
                $emailArray += $email
                Write-Host -ForegroundColor $processmessagecolor "Added: $email"
            }
            else {
                Write-Host -ForegroundColor $errormessagecolor "Invalid email address: $email"
            }
        }
    }
    catch {
        Write-Host -ForegroundColor $warningmessagecolor "Error during email input: $($_.Exception.Message)"
        break
    }
} until ($email -eq "")

# If we still have no emails, use a default
if (($emailArray | Measure-Object).Count -eq 0) {
    Write-Host -ForegroundColor $processmessagecolor "Using default admin email for notifications"
    $emailArray = @("securityadmin@yourdomain.com")
}

# Remove duplicates and create the final notification list
$notifyUsers = $emailArray | Select-Object -Unique
Write-Host -ForegroundColor $processmessagecolor "Total notification addresses: $(($notifyUsers | Measure-Object).count)"

# Get all domains in the tenant
Write-Host -ForegroundColor $processmessagecolor "Getting all domains in tenant..."
$domains = $null
$recipientDomain = @()

# First try Graph if available
if ($graphModuleAvailable -and $context) {
    try {
        $domains = Get-MgDomain -ErrorAction Stop
        $recipientDomain = $domains.Id
        Write-Host -ForegroundColor $processmessagecolor "Found $(($domains | Measure-Object).count) domains in tenant via Graph"
    }
    catch {
        Write-Host -ForegroundColor $warningmessagecolor "Unable to retrieve domains via Graph: $($_.Exception.Message)"
        $domains = $null
    }
}

# If Graph failed or not available, use Exchange Online
if (-not $domains) {
    try {
        $acceptedDomains = Get-AcceptedDomain -ErrorAction Stop
        $recipientDomain = $acceptedDomains.DomainName
        
        # Create a simple object to match the structure we expect
        $domains = @()
        foreach ($domain in $acceptedDomains) {
            $domains += [PSCustomObject]@{
                Id = $domain.DomainName
                Name = $domain.DomainName
            }
        }
        
        Write-Host -ForegroundColor $processmessagecolor "Found $(($recipientDomain | Measure-Object).count) domains in tenant from Exchange Online"
    }
    catch {
        Write-Host -ForegroundColor $errormessagecolor "Error retrieving domains from Exchange Online: $($_.Exception.Message)"
        # Create at least an empty array to avoid null reference errors
        $domains = @()
        $recipientDomain = @()
    }
}

# Check for required quarantine policies
Write-Host -ForegroundColor $processmessagecolor "[Info] = Checking for required quarantine policies"
try {
    $quarpolicy = Get-QuarantinePolicy -ErrorAction Stop
    $bpfound = $false
    
    foreach ($policy in $quarpolicy) {
        If ($policy.name -match 'BP - Quarantine Policy'){
            Write-Host -ForegroundColor $processmessagecolor "Best Practice Quarantine Policy found: $($policy.Name)"
            $bpfound = $true
        }
    }
    
    if ($bpfound -eq $false){
        Write-Host -ForegroundColor $processmessagecolor "Creating Best Practice Quarantine policy..."
        
        # Check if o365-mx-quar-set.ps1 exists
        # Debug info about paths
        if ($debug) {
            Write-Host -ForegroundColor $processmessagecolor "Current script path from MyInvocation: $($MyInvocation.MyCommand.Path)"
            Write-Host -ForegroundColor $processmessagecolor "Current location: $(Get-Location)"
            Write-Host -ForegroundColor $processmessagecolor "Current username: $env:USERNAME"
            Write-Host -ForegroundColor $processmessagecolor "User profile path: $env:USERPROFILE"
        }
        
        # Define a list of potential paths to check
        Write-Host -ForegroundColor $processmessagecolor "Checking multiple locations for quarantine script..."
        $potentialPaths = @()
        
        # Try current script directory first if available
        if ($MyInvocation.MyCommand.Path) { 
            $potentialPaths += Join-Path (Split-Path -Parent $MyInvocation.MyCommand.Path) "o365-mx-quar-set.ps1"
        }
        
        # Add all other potential paths
        $potentialPaths += Join-Path (Get-Location).Path "o365-mx-quar-set.ps1"
        $potentialPaths += "$env:USERPROFILE\OneDrive\2. IT\3. SCRIPTS\OFFICE 365\patron-master\o365-mx-quar-set.ps1"
        $potentialPaths += "C:\Users\smhow\OneDrive\2. IT\3. SCRIPTS\OFFICE 365\patron-master\o365-mx-quar-set.ps1"
        $potentialPaths += "/mnt/c/Users/$env:USERNAME/OneDrive/2. IT/3. SCRIPTS/OFFICE 365/patron-master/o365-mx-quar-set.ps1"
        $potentialPaths += "/mnt/c/Users/smhow/OneDrive/2. IT/3. SCRIPTS/OFFICE 365/patron-master/o365-mx-quar-set.ps1"
        
        $quarScriptPath = $null
        foreach ($path in $potentialPaths) {
            Write-Host -ForegroundColor $processmessagecolor "  Checking for quarantine script at: $path"
            if (Test-Path $path) {
                Write-Host -ForegroundColor $processmessagecolor "  [FOUND] Script exists at: $path"
                $quarScriptPath = $path
                break
            } else {
                Write-Host -ForegroundColor $warningmessagecolor "  [NOT FOUND] Script does not exist at: $path"
            }
        }
        
        if (-not $quarScriptPath) {
            # Default to current directory as fallback
            $quarScriptPath = Join-Path (Get-Location).Path "o365-mx-quar-set.ps1"
        }
        
        # Final script path determination complete
        if (Test-Path $quarScriptPath) {
            try {
                Write-Host -ForegroundColor $processmessagecolor "Running quarantine policy script: $quarScriptPath"
                & $quarScriptPath
                Write-Host -ForegroundColor $processmessagecolor "Best Practice Quarantine policy created"
                $quarantinePolicyCreated = $true
            }
            catch {
                Write-Host -ForegroundColor $warningmessagecolor "Error running quarantine script: $($_.Exception.Message)"
                Write-Host -ForegroundColor $processmessagecolor "Will continue with default quarantine policy values"
            }
        } else {
            Write-Host -ForegroundColor $warningmessagecolor "Script o365-mx-quar-set.ps1 not found at path: $quarScriptPath"
            Write-Host -ForegroundColor $processmessagecolor "Quarantine policy will need to be created manually"
            Write-Host -ForegroundColor $processmessagecolor "Will continue with default quarantine policy values"
        }
    }
}
catch {
    Write-Host -ForegroundColor $warningmessagecolor "Unable to check quarantine policies: $($_.Exception.Message)"
    Write-Host -ForegroundColor $processmessagecolor "Will continue with default quarantine policy values"
}

# Check for required malware policies
Write-Host -ForegroundColor $processmessagecolor "[Info] = Checking for required malware policies"
try {
    $malwarePolicy = Get-MalwareFilterPolicy -ErrorAction Stop
    $bpFound = $false
    
    # The malware script uses API to get the policy name, but typically it's "Best Practices Malware Policy"
    foreach ($policy in $malwarePolicy) {
        If ($policy.name -match 'Best Practices Malware Policy|BP - Malware Policy'){
            Write-Host -ForegroundColor $processmessagecolor "Best Practice Malware Policy found: $($policy.Name)"
            $bpFound = $true
        }
    }
    
    if ($bpFound -eq $false){
        Write-Host -ForegroundColor $processmessagecolor "Creating Best Practice Malware policy..."
        
        # Check if o365-mx-malware-set.ps1 exists
        # Define a list of potential paths to check
        Write-Host -ForegroundColor $processmessagecolor "Checking multiple locations for malware script..."
        $potentialPaths = @()
        
        # Try current script directory first if available
        if ($MyInvocation.MyCommand.Path) { 
            $potentialPaths += Join-Path (Split-Path -Parent $MyInvocation.MyCommand.Path) "o365-mx-malware-set.ps1"
        }
        
        # Add all other potential paths
        $potentialPaths += Join-Path (Get-Location).Path "o365-mx-malware-set.ps1"
        $potentialPaths += "$env:USERPROFILE\OneDrive\2. IT\3. SCRIPTS\OFFICE 365\patron-master\o365-mx-malware-set.ps1"
        $potentialPaths += "C:\Users\smhow\OneDrive\2. IT\3. SCRIPTS\OFFICE 365\patron-master\o365-mx-malware-set.ps1"
        $potentialPaths += "/mnt/c/Users/$env:USERNAME/OneDrive/2. IT/3. SCRIPTS/OFFICE 365/patron-master/o365-mx-malware-set.ps1"
        $potentialPaths += "/mnt/c/Users/smhow/OneDrive/2. IT/3. SCRIPTS/OFFICE 365/patron-master/o365-mx-malware-set.ps1"
        
        $malwareScriptPath = $null
        foreach ($path in $potentialPaths) {
            Write-Host -ForegroundColor $processmessagecolor "  Checking for malware script at: $path"
            if (Test-Path $path) {
                Write-Host -ForegroundColor $processmessagecolor "  [FOUND] Script exists at: $path"
                $malwareScriptPath = $path
                break
            } else {
                Write-Host -ForegroundColor $warningmessagecolor "  [NOT FOUND] Script does not exist at: $path"
            }
        }
        
        if (-not $malwareScriptPath) {
            # Default to current directory as fallback
            $malwareScriptPath = Join-Path (Get-Location).Path "o365-mx-malware-set.ps1"
        }
        
        # Final script path determination complete
        if (Test-Path $malwareScriptPath) {
            try {
                Write-Host -ForegroundColor $processmessagecolor "Running malware policy script: $malwareScriptPath"
                & $malwareScriptPath
                Write-Host -ForegroundColor $processmessagecolor "Best Practice Malware policy created"
                $malwarePolicyCreated = $true
            }
            catch {
                Write-Host -ForegroundColor $warningmessagecolor "Error running malware script: $($_.Exception.Message)"
                Write-Host -ForegroundColor $processmessagecolor "Will continue with default malware policy values"
            }
        } else {
            Write-Host -ForegroundColor $warningmessagecolor "Script o365-mx-malware-set.ps1 not found at path: $malwareScriptPath"
            Write-Host -ForegroundColor $processmessagecolor "Malware policy will need to be created manually"
            Write-Host -ForegroundColor $processmessagecolor "Will continue with default malware policy values"
        }
    }
}
catch {
    Write-Host -ForegroundColor $warningmessagecolor "Unable to check malware policies: $($_.Exception.Message)"
    Write-Host -ForegroundColor $processmessagecolor "Will continue with default malware policy values"
}

# Get best practices from custom API
Write-Host -ForegroundColor $processmessagecolor "[Info] = Reading Best Practices from API"
try {
    # Using the same custom API endpoint as the original script
    $query = Invoke-WebRequest -Method GET -ContentType "application/json" -Uri "https://ciaopsgraph.azurewebsites.net/api/f9833ef6b5db63746a2322e085c39eff?id=f32652977bdc0f08a71071ad4739a601" -UseBasicParsing -ErrorAction Stop
    $inboundSpamBestPractices = $query.Content | ConvertFrom-Json
    
    # Save the policy name from the API response
    $inboundPolicyName = $inboundSpamBestPractices.name
    if ([string]::IsNullOrEmpty($inboundPolicyName)) {
        $inboundPolicyName = "Best Practices Spam Policy"
    }
    
    Write-Host -ForegroundColor $processmessagecolor "Successfully retrieved inbound best practices from API"
}
catch {
    $continue = HandleError -ErrorMessage "Failed to retrieve inbound best practices from API: $($_.Exception.Message)" -ErrorCode "API001" -ExitScript $false
    if (-not $continue) { return }
    
    Write-Host -ForegroundColor $processmessagecolor "Using default inbound best practice values instead"
    
    # Create default values to allow script to continue
    $inboundSpamBestPractices = [PSCustomObject]@{
        name = "Best Practices Spam Policy"
        bulkspamaction = "MoveToJmf"
        bulkthreshold = 6
        SpamQuarantineTag = "DefaultFullAccessWithNotificationPolicy"
        PhishQuarantineTag = "DefaultFullAccessWithNotificationPolicy"
        HighConfidenceSpamQuarantineTag = "DefaultFullAccessWithNotificationPolicy"
        HighConfidencePhishQuarantineTag = "DefaultFullAccessWithNotificationPolicy"
        BulkQuarantineTag = "DefaultFullAccessWithNotificationPolicy"
        HighConfidenceSpamAction = "Quarantine"
        EnableEndUserSpamNotifications = $true
        EndUserSpamNotificationFrequency = 1
        QuarantineRetentionPeriod = 30
        InlineSafetyTipsEnabled = $true
        Markasspambulkmail = $true
        EnableLanguageBlockList = $true
        EnableRegionBlockList = $true
        IncreaseScoreWithImageLinks = $false
        IncreaseScoreWithNumericIps = $false
        IncreaseScoreWithRedirectToOtherPort = $false
        IncreaseScoreWithBizOrInfoUrls = $false
        Markasspamemptymessages = $false
        Markasspamjavascriptinhtml = $false
        Markasspamframesinhtml = $false
        Markasspamobjecttagsinhtml = $false
        MarkAsSpamEmbedTagsInHtml = $false
        Markasspamformtagsinhtml = $false
        Markasspamwebbugsinhtml = $false
        Markasspamsensitivewordlist = $false
        Markasspamspfrecordhardfail = $false
        Markasspamfromaddressauthfail = $false
        Markasspamndrbackscatter = $false
        PhishSpamAction = "Quarantine"
        Spamaction = "MoveToJmf"
        ZapEnabled = $true
        SpamZapEnabled = $true
        phishZapenabled = $true
    }
    
    $inboundPolicyName = $inboundSpamBestPractices.name
}

# Get inbound spam policies
Write-Host -ForegroundColor $processmessagecolor "[Info] = Check for existing inbound spam policies"
try {
    $spampolicy = Get-HostedContentFilterPolicy -ErrorAction Stop
}
catch {
    $continue = HandleError -ErrorMessage "Error retrieving policies: $($_.Exception.Message)" -ErrorCode "006" -ExitScript $false
    if (-not $continue) { return }
    $spampolicy = @()
}

Write-Host -ForegroundColor $warningmessagecolor -BackgroundColor DarkGreen "`nCheck for existing Inbound Spam policies"
Write-Host -ForegroundColor $processmessagecolor "Total number of inbound policies = ", ($spampolicy | Measure-Object).Count, "`n"

# Check if the Best Practices policy exists
$bpPolicyExists = $false
$bpPolicy = $null

foreach ($policy in $spampolicy) {
    if ($policy.Name -eq $inboundPolicyName) {
        $bpPolicyExists = $true
        $bpPolicy = $policy
        Write-Host -ForegroundColor $processmessagecolor "Found Best Practices policy: $($policy.Name)"
        break
    }
}

# Create the Best Practices policy if it doesn't exist and creation is enabled
if (-not $bpPolicyExists -and $createPolicy) {
    Write-Host -ForegroundColor $processmessagecolor "Creating new Best Practices inbound spam filter policy: $inboundPolicyName"
    
    $policyParams = @{
        'Name' = $inboundPolicyName
        'BulkQuarantineTag' = $inboundSpamBestPractices.BulkQuarantineTag
        'Bulkspamaction' = $inboundSpamBestPractices.Bulkspamaction
        'BulkThreshold' = $inboundSpamBestPractices.bulkthreshold
        'EnableEnduserSpamNotifications' = $inboundSpamBestPractices.EnableEnduserSpamNotifications
        'EnableLanguageBlockList' = $inboundSpamBestPractices.enablelanguageblocklist
        'EnableRegionBlockList' = $inboundSpamBestPractices.enableregionblocklist
        'EndUserSpamNotificationFrequency' = $inboundSpamBestPractices.EndUserSpamNotificationFrequency
        'HighConfidencePhishAction' = $inboundSpamBestPractices.HighConfidencePhishAction
        'HighConfidenceSpamQuarantineTag' = $inboundSpamBestPractices.HighConfidenceSpamQuarantineTag
        'HighConfidenceSpamAction' = $inboundSpamBestPractices.highconfidencespamaction
        'HighConfidencePhishQuarantineTag' = $inboundSpamBestPractices.HighConfidencePhishQuarantineTag
        'IncreaseScoreWithBizOrInfoUrls' = $inboundSpamBestPractices.increasescorewithbizorinfourls
        'IncreaseScoreWithImageLinks' = $inboundSpamBestPractices.increasescorewithimagelinks
        'IncreaseScoreWithNumericIps' = $inboundSpamBestPractices.increasescorewithnumericips
        'IncreaseScoreWithRedirectToOtherPort' = $inboundSpamBestPractices.increasescorewithredirecttootherport
        'InlineSafetyTipsEnabled' = $inboundSpamBestPractices.inlinesafetytipsenabled
        'LanguageBlocklist' = $DefaultLanguageBlockList
        'MarkAsSpamBulkMail' = $inboundSpamBestPractices.markasspambulkmail
        'MarkAsSpamEmbedTagsInHtml' = $inboundSpamBestPractices.markasspamembedtagsinhtml
        'MarkAsSpamEmptyMessages' = $inboundSpamBestPractices.markasspamemptymessages
        'MarkAsSpamFormTagsInHtml' = $inboundSpamBestPractices.markasspamformtagsinhtml
        'MarkAsSpamFramesInHtml' = $inboundSpamBestPractices.markasspamframesinhtml
        'MarkAsSpamFromAddressAuthFail' = $inboundSpamBestPractices.markasspamfromaddressauthfail
        'MarkAsSpamJavaScriptInHtml' = $inboundSpamBestPractices.markasspamembedtagsinhtml
        'MarkAsSpamNdrBackscatter' = $inboundSpamBestPractices.markasspamndrbackscatter
        'MarkAsSpamObjectTagsInHtml' = $inboundSpamBestPractices.markasspamobjecttagsinhtml
        'MarkAsSpamSensitiveWordList' = $inboundSpamBestPractices.markasspamsensitivewordlist
        'MarkAsSpamSpfRecordHardFail' = $inboundSpamBestPractices.markasspamspfrecordhardfail
        'MarkAsSpamWebBugsInHtml' = $inboundSpamBestPractices.markasspamwebbugsinhtml
        'PhishQuarantineTag' = $inboundSpamBestPractices.PhishQuarantineTag
        'PhishSpamAction' = $inboundSpamBestPractices.phishspamaction
        'PhishZapEnabled' = $inboundSpamBestPractices.phishzapenabled
        'QuarantineRetentionPeriod' = $inboundSpamBestPractices.QuarantineRetentionPeriod
        'RegionBlockList' = $DefaultRegionBlockList
        'SpamAction' = $inboundSpamBestPractices.spamaction
        'SpamQuarantineTag' = $inboundSpamBestPractices.SpamQuarantineTag
        'SpamZapenabled' = $inboundSpamBestPractices.spamzapenabled
    }

    try {
        $newPolicy = New-HostedContentFilterPolicy @policyParams -ErrorAction Stop
        Write-Host -ForegroundColor $processmessagecolor "Successfully created new Best Practices inbound spam policy: $($newPolicy.Name)"
        $bpPolicy = $newPolicy
        $bpPolicyExists = $true
    }
    catch {
        Write-Host -ForegroundColor $errormessagecolor "Error creating new Best Practices policy: $($_.Exception.Message)"
    }
}

# Check each inbound spam policy
# If we created or found a Best Practices policy, check/update only that one
# Otherwise check all policies
$policiesToCheck = @()
if ($bpPolicyExists) {
    $policiesToCheck += $bpPolicy
} else {
    $policiesToCheck = $spampolicy
}

Foreach ($policy in $policiesToCheck) {
    try {
        Write-Host -ForegroundColor Gray -BackgroundColor Blue "Inbound Spam Policy name = ", $policy.name
        $updateNeeded = $false
        $updateParams = @{}
        
        # BulkSpamAction
        if ($policy.bulkspamaction -ne $inboundSpamBestPractices.bulkspamaction) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Bulk Spam Action:", $policy.bulkspamaction, $fail
            $updateParams.Add("BulkSpamAction", $inboundSpamBestPractices.bulkspamaction)
            $updateNeeded = $true
        }
        else { 
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Bulk Spam Action:", $policy.bulkspamaction, $pass
        }
        
        # BulkThreshold
        if ($policy.bulkthreshold -gt $inboundSpamBestPractices.bulkthreshold) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Bulk threshold level:", $policy.bulkthreshold, $fail
            $updateParams.Add("BulkThreshold", $inboundSpamBestPractices.bulkthreshold)
            $updateNeeded = $true
        }
        else { 
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Bulk threshold level:", $policy.bulkthreshold, $pass
        }
        
        # SpamQuarantineTag
        if ($policy.SpamQuarantineTag -ne $inboundSpamBestPractices.SpamQuarantineTag) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Spam Quarantine Tag is:", $policy.SpamQuarantineTag, "Should be: $($inboundSpamBestPractices.SpamQuarantineTag)", $fail
            $updateParams.Add("SpamQuarantineTag", $inboundSpamBestPractices.SpamQuarantineTag)
            $updateNeeded = $true
        }
        else { 
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Spam Quarantine Tag:", $policy.SpamQuarantineTag, $pass
        }
        
        # PhishQuarantineTag
        if ($policy.PhishQuarantineTag -ne $inboundSpamBestPractices.PhishQuarantineTag) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Phish Quarantine Tag is:", $policy.PhishQuarantineTag, "Should be: $($inboundSpamBestPractices.PhishQuarantineTag)", $fail
            $updateParams.Add("PhishQuarantineTag", $inboundSpamBestPractices.PhishQuarantineTag)
            $updateNeeded = $true
        }
        else { 
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Phish Quarantine Tag:", $policy.PhishQuarantineTag, $pass
        }
        
        # HighConfidenceSpamQuarantineTag
        if ($policy.HighConfidenceSpamQuarantineTag -ne $inboundSpamBestPractices.HighConfidenceSpamQuarantineTag) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] High Confidence Spam Quarantine Tag is:", $policy.HighConfidenceSpamQuarantineTag, "Should be: $($inboundSpamBestPractices.HighConfidenceSpamQuarantineTag)", $fail
            $updateParams.Add("HighConfidenceSpamQuarantineTag", $inboundSpamBestPractices.HighConfidenceSpamQuarantineTag)
            $updateNeeded = $true
        }
        else { 
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] High Confidence Spam Quarantine Tag:", $policy.HighConfidenceSpamQuarantineTag, $pass
        }
        
        # HighConfidencePhishQuarantineTag
        if ($policy.HighConfidencePhishQuarantineTag -ne $inboundSpamBestPractices.HighConfidencePhishQuarantineTag) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] High Confidence Phish Quarantine Tag is:", $policy.HighConfidencePhishQuarantineTag, "Should be: $($inboundSpamBestPractices.HighConfidencePhishQuarantineTag)", $fail
            $updateParams.Add("HighConfidencePhishQuarantineTag", $inboundSpamBestPractices.HighConfidencePhishQuarantineTag)
            $updateNeeded = $true
        }
        else { 
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] High Confidence Phish Quarantine Tag:", $policy.HighConfidencePhishQuarantineTag, $pass
        }
        
        # BulkQuarantineTag
        if ($policy.BulkQuarantineTag -ne $inboundSpamBestPractices.BulkQuarantineTag) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Bulk Quarantine Tag is:", $policy.BulkQuarantineTag, "Should be: $($inboundSpamBestPractices.BulkQuarantineTag)", $fail
            $updateParams.Add("BulkQuarantineTag", $inboundSpamBestPractices.BulkQuarantineTag)
            $updateNeeded = $true
        }
        else { 
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Bulk Quarantine Tag:", $policy.BulkQuarantineTag, $pass
        }
        
        # HighConfidenceSpamAction
        if ($policy.Highconfidencespamaction -ne $inboundSpamBestPractices.HighConfidenceSpamAction) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] High confidence spam action:", $policy.Highconfidencespamaction, $fail
            $updateParams.Add("HighConfidenceSpamAction", $inboundSpamBestPractices.HighConfidenceSpamAction)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] High confidence spam action:", $policy.Highconfidencespamaction, $pass
        }
        
        # EnableEndUserSpamNotifications
        if ($policy.EnableEndUserSpamNotifications -ne $inboundSpamBestPractices.EnableEndUserSpamNotifications) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Notify end users of quarantined spam is set to:", $policy.EnableEndUserSpamNotifications, $fail
            $updateParams.Add("EnableEndUserSpamNotifications", $inboundSpamBestPractices.EnableEndUserSpamNotifications)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Notify end users of quarantined spam is set to:", $policy.EnableEndUserSpamNotifications, $pass
        }
        
        # EndUserSpamNotificationFrequency
        if ($policy.EndUserSpamNotificationFrequency -ne $inboundSpamBestPractices.EndUserSpamNotificationFrequency) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] End user quarantine notification frequency (days):", $policy.EndUserSpamNotificationFrequency, $fail
            $updateParams.Add("EndUserSpamNotificationFrequency", $inboundSpamBestPractices.EndUserSpamNotificationFrequency)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] End user quarantine notification frequency (days):", $policy.EndUserSpamNotificationFrequency, $pass
        }
        
        # QuarantineRetentionPeriod
        if ($policy.QuarantineRetentionPeriod -ne $inboundSpamBestPractices.QuarantineRetentionPeriod) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Quarantine Retention Period:", $policy.QuarantineRetentionPeriod, $fail
            $updateParams.Add("QuarantineRetentionPeriod", $inboundSpamBestPractices.QuarantineRetentionPeriod)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Quarantine Retention Period:", $policy.QuarantineRetentionPeriod, $pass
        }
        
        # InlineSafetyTipsEnabled
        if ($policy.Inlinesafetytipsenabled -ne $inboundSpamBestPractices.InlineSafetyTipsEnabled) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Inline safety tips disabled", $fail
            $updateParams.Add("InlineSafetyTipsEnabled", $inboundSpamBestPractices.InlineSafetyTipsEnabled)
            $updateNeeded = $true
        } 
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Inline safety tips enabled", $pass
        }
        
        # MarkAsSpamBulkMail
        if ($policy.Markasspambulkmail -ne $inboundSpamBestPractices.Markasspambulkmail) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam bulk email is off", $fail
            $updateParams.Add("MarkAsSpamBulkMail", $inboundSpamBestPractices.Markasspambulkmail)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam bulk email is on", $pass
        }
        
        # EnableLanguageBlockList
        if ($policy.Enablelanguageblocklist -ne $inboundSpamBestPractices.EnableLanguageBlockList) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Enable language block list is disabled", $fail
            $updateParams.Add("EnableLanguageBlockList", $inboundSpamBestPractices.EnableLanguageBlockList)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Enable language block list is enabled", $pass
        }
        
        # LanguageBlockList
        if (IsCollectionEmpty $policy.Languageblocklist) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Language block list is empty", $fail
            $updateParams.Add("LanguageBlockList", $DefaultLanguageBlockList)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Language block list is not empty", $pass
            Write-Host -ForegroundColor Gray "   Language block list contains:"
            foreach ($language in $policy.Languageblocklist) {
                Write-Host -ForegroundColor Gray "        - ", $language
            }
        }
        
        # EnableRegionBlockList
        if ($policy.Enableregionblocklist -ne $inboundSpamBestPractices.EnableRegionBlockList) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Enable region block list is disabled", $fail
            $updateParams.Add("EnableRegionBlockList", $inboundSpamBestPractices.EnableRegionBlockList)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Enable region block list is enabled", $pass
        }
        
        # RegionBlockList
        if (IsCollectionEmpty $policy.regionblocklist) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Region block list is empty", $fail
            $updateParams.Add("RegionBlockList", $DefaultRegionBlockList)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Region block list is not empty", $pass
            Write-Host -ForegroundColor Gray "   Region block list contains:"
            foreach ($region in $policy.regionblocklist) {
                Write-Host -ForegroundColor Gray "        - ", $region
            }
        }
        
        # IncreaseScoreWithImageLinks
        if ($policy.Increasescorewithimagelinks -ne $inboundSpamBestPractices.IncreaseScoreWithImageLinks) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Increase score with image links is on", $fail
            $updateParams.Add("IncreaseScoreWithImageLinks", $inboundSpamBestPractices.IncreaseScoreWithImageLinks)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Increase score with image links is off", $pass
        }
        
        # IncreaseScoreWithNumericIps
        if ($policy.Increasescorewithnumericips -ne $inboundSpamBestPractices.IncreaseScoreWithNumericIps) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Increase score with numeric IPs is on", $fail
            $updateParams.Add("IncreaseScoreWithNumericIps", $inboundSpamBestPractices.IncreaseScoreWithNumericIps)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Increase score with numeric IPs is off", $pass
        }
        
        # IncreaseScoreWithRedirectToOtherPort
        if ($policy.Increasescorewithredirecttootherport -ne $inboundSpamBestPractices.IncreaseScoreWithRedirectToOtherPort) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Increase score with redirect to other port is on", $fail
            $updateParams.Add("IncreaseScoreWithRedirectToOtherPort", $inboundSpamBestPractices.IncreaseScoreWithRedirectToOtherPort)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Increase score with redirect to other port is off", $pass
        }
        
        # IncreaseScoreWithBizOrInfoUrls
        if ($policy.Increasescorewithbizorinfourls -ne $inboundSpamBestPractices.IncreaseScoreWithBizOrInfoUrls) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Increase score with .biz or .info in URLs is on", $fail
            $updateParams.Add("IncreaseScoreWithBizOrInfoUrls", $inboundSpamBestPractices.IncreaseScoreWithBizOrInfoUrls)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Increase score with .biz or .info in URLs is off", $pass
        }
        
        # MarkAsSpamEmptyMessages
        if ($policy.Markasspamemptymessages -ne $inboundSpamBestPractices.Markasspamemptymessages) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam empty messages as spam is on", $fail
            $updateParams.Add("MarkAsSpamEmptyMessages", $inboundSpamBestPractices.Markasspamemptymessages)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam empty messages as spam is off", $pass
        }
        
        # MarkAsSpamJavaScriptInHtml
        if ($policy.Markasspamjavascriptinhtml -ne $inboundSpamBestPractices.Markasspamjavascriptinhtml) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam javascript in HTML is on", $fail
            $updateParams.Add("MarkAsSpamJavaScriptInHtml", $inboundSpamBestPractices.Markasspamjavascriptinhtml)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam javascript in HTML is off", $pass
        }
        
        # MarkAsSpamFramesInHtml
        if ($policy.Markasspamframesinhtml -ne $inboundSpamBestPractices.Markasspamframesinhtml) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam frames in HTML is on", $fail
            $updateParams.Add("MarkAsSpamFramesInHtml", $inboundSpamBestPractices.Markasspamframesinhtml)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam frames in HTML is off", $pass
        }
        
        # MarkAsSpamObjectTagsInHtml
        if ($policy.Markasspamobjecttagsinhtml -ne $inboundSpamBestPractices.Markasspamobjecttagsinhtml) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam object tags in HTML is on", $fail
            $updateParams.Add("MarkAsSpamObjectTagsInHtml", $inboundSpamBestPractices.Markasspamobjecttagsinhtml)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam object tags in HTML is off", $pass
        }
        
        # MarkAsSpamEmbedTagsInHtml
        if ($policy.Markasspamembedtagsinhtml -ne $inboundSpamBestPractices.MarkAsSpamEmbedTagsInHtml) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam embedded tags in HTML is on", $fail
            $updateParams.Add("MarkAsSpamEmbedTagsInHtml", $inboundSpamBestPractices.MarkAsSpamEmbedTagsInHtml)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam embedded tags in HTML is off", $pass
        }
        
        # MarkAsSpamFormTagsInHtml
        if ($policy.Markasspamformtagsinhtml -ne $inboundSpamBestPractices.Markasspamformtagsinhtml) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam form tags in HTML is on", $fail
            $updateParams.Add("MarkAsSpamFormTagsInHtml", $inboundSpamBestPractices.Markasspamformtagsinhtml)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam form tags in HTML is off", $pass
        }
        
        # MarkAsSpamWebBugsInHtml
        if ($policy.Markasspamwebbugsinhtml -ne $inboundSpamBestPractices.Markasspamwebbugsinhtml) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam web bugs in HTML is on", $fail
            $updateParams.Add("MarkAsSpamWebBugsInHtml", $inboundSpamBestPractices.Markasspamwebbugsinhtml)
            $updateNeeded = $true
        } else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam web bugs in HTML is off", $pass
        }
        
        # MarkAsSpamSensitiveWordList
        if ($policy.Markasspamsensitivewordlist -ne $inboundSpamBestPractices.Markasspamsensitivewordlist) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam sensitive word list is on", $fail
            $updateParams.Add("MarkAsSpamSensitiveWordList", $inboundSpamBestPractices.Markasspamsensitivewordlist)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam sensitive word list is off", $pass
        }
        
        # MarkAsSpamSpfRecordHardFail
        if ($policy.Markasspamspfrecordhardfail -ne $inboundSpamBestPractices.Markasspamspfrecordhardfail) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam SPF hard fail is on", $fail
            $updateParams.Add("MarkAsSpamSpfRecordHardFail", $inboundSpamBestPractices.Markasspamspfrecordhardfail)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam SPF hard fail is off", $pass
        }
        
        # MarkAsSpamFromAddressAuthFail
        if ($policy.Markasspamfromaddressauthfail -ne $inboundSpamBestPractices.Markasspamfromaddressauthfail) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam from address auth fail is on", $fail
            $updateParams.Add("MarkAsSpamFromAddressAuthFail", $inboundSpamBestPractices.Markasspamfromaddressauthfail)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam from address auth fail is off", $pass
        }
        
        # MarkAsSpamNdrBackscatter
        if ($policy.Markasspamndrbackscatter -ne $inboundSpamBestPractices.Markasspamndrbackscatter) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Mark as spam back scatter is on", $fail
            $updateParams.Add("MarkAsSpamNdrBackscatter", $inboundSpamBestPractices.Markasspamndrbackscatter)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Mark as spam back scatter is off", $pass
        }
        
        # PhishSpamAction
        if ($policy.Phishspamaction -ne $inboundSpamBestPractices.PhishSpamAction) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Phish spam action not set to best practices:", $policy.Phishspamaction, $fail
            $updateParams.Add("PhishSpamAction", $inboundSpamBestPractices.PhishSpamAction)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Phish spam action set to best practices:", $policy.Phishspamaction, $pass
        }
        
        # SpamAction
        if ($policy.Spamaction -ne $inboundSpamBestPractices.Spamaction) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Spam action not set to best practices:", $policy.Spamaction, $fail
            $updateParams.Add("SpamAction", $inboundSpamBestPractices.Spamaction)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Spam action set to best practices:", $policy.Spamaction, $pass
        }
        
        # ZapEnabled
        if ($policy.Zapenabled -ne $inboundSpamBestPractices.ZapEnabled) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Zap action disabled", $fail
            $updateParams.Add("ZapEnabled", $inboundSpamBestPractices.ZapEnabled)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Zap action enabled", $pass
        }
        
        # SpamZapEnabled
        if ($policy.SpamZapenabled -ne $inboundSpamBestPractices.SpamZapEnabled) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Spam Zap action disabled", $fail
            $updateParams.Add("SpamZapEnabled", $inboundSpamBestPractices.SpamZapEnabled)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Spam Zap action enabled", $pass
        }
        
        # PhishZapEnabled
        if ($policy.phishZapenabled -ne $inboundSpamBestPractices.phishZapenabled) {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Phish Zap action disabled", $fail
            $updateParams.Add("PhishZapEnabled", $inboundSpamBestPractices.phishZapenabled)
            $updateNeeded = $true
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Phish Zap action enabled", $pass
        }
        
        # AllowedSenders - best practice is to have this empty
        if (IsCollectionEmpty $policy.allowedsenders) {    
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Allowed Senders is empty", $pass
        }
        else {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Allowed Senders is not empty", $fail
            foreach ($sender in $policy.allowedsenders) {
                Write-Host -ForegroundColor $errormessagecolor "        - ", $sender
            }
            $updateParams.Add("AllowedSenders", @())
            $updateNeeded = $true
        }
        
        # AllowedSenderDomains - best practice is to have this empty
        if (IsCollectionEmpty $policy.allowedsenderdomains) {    
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Allowed Sender domains is empty", $pass
        }
        else {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Allowed Sender domains is not empty", $fail
            foreach ($sender in $policy.allowedsenderdomains) {
                Write-Host -ForegroundColor $errormessagecolor "        - ", $sender
            }
            $updateParams.Add("AllowedSenderDomains", @())
            $updateNeeded = $true
        }
        
        # BlockedSenders - best practice is to have this empty (use central tenant block lists instead)
        if (IsCollectionEmpty $policy.blockedsenders) {    
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Blocked Senders is empty", $pass
        }
        else {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Blocked Senders is not empty", $fail
            foreach ($sender in $policy.blockedsenders) {
                Write-Host -ForegroundColor $errormessagecolor "        - ", $sender
            }
            $updateParams.Add("BlockedSenders", @())
            $updateNeeded = $true
        }
        
        # BlockedSenderDomains - best practice is to have this empty (use central tenant block lists instead)
        if (IsCollectionEmpty $policy.blockedsenderdomains) {    
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Blocked Sender domains is empty", $pass
        }
        else {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Blocked Sender domains is not empty", $fail
            foreach ($sender in $policy.blockedsenderdomains) {
                Write-Host -ForegroundColor $errormessagecolor "        - ", $sender
            }
            $updateParams.Add("BlockedSenderDomains", @())
            $updateNeeded = $true
        }
        
        # Apply updates if needed and auto-apply is enabled
        if ($updateNeeded -and $autoApply) {
            try {
                Write-Host -ForegroundColor $processmessagecolor "`n   Applying best practice settings to policy '$($policy.Name)'..."
                $updateParams.Add("Identity", $policy.Name)
                
                # Execute the Set-HostedContentFilterPolicy command with our parameters
                Set-HostedContentFilterPolicy @updateParams -ErrorAction Stop
                
                Write-Host -ForegroundColor $processmessagecolor "   Changes applied successfully to policy '$($policy.Name)'."
            }
            catch {
                Write-Host -ForegroundColor $errormessagecolor "   [ERROR] Failed to update policy '$($policy.Name)': $($_.Exception.Message)"
            }
        }
        elseif ($updateNeeded -and -not $autoApply) {
            Write-Host -ForegroundColor $warningmessagecolor "`n   Changes required for policy '$($policy.Name)' but auto-apply is disabled."
        }
        else {
            Write-Host -ForegroundColor $processmessagecolor "`n   No changes needed for policy '$($policy.Name)'."
        }
        
        Write-Host
    }
    catch {
        Write-Host -ForegroundColor $errormessagecolor "   [ERROR] Error processing policy '$($policy.name)': $($_.Exception.Message)"
        continue
    }
}

# Get existing Inbound rules using consolidated function
try {
    Write-Host -ForegroundColor $warningmessagecolor -BackgroundColor DarkGreen "Check for existing Inbound Spam rules"
    $ruleparams = Get-HostedContentFilterRule -ErrorAction Stop
    Write-Host -ForegroundColor $processmessagecolor "Total number of inbound rules = ", ($ruleparams | Measure-Object).Count, "`n"
    
    # Define our Best Practice rule name
    $bpRuleName = "Best Practices Inbound Spam Rule"
    $bpRuleExists = $false
    $bpRule = $null
    
    if ($ruleparams) {
        # First check if we have a rule for the Best Practices policy
        foreach ($rule in $ruleparams) {
            if (($rule.Name -eq $bpRuleName) -or ($rule.HostedContentFilterPolicy -eq $inboundPolicyName)) {
                $bpRuleExists = $true
                $bpRule = $rule
                Write-Host -ForegroundColor $processmessagecolor "Found rule for Best Practices policy: $($rule.Name)"
                break
            }
        }
    }
    
    # Make sure we have domains to work with
    $domainsList = if ($recipientDomain -and ($recipientDomain | Measure-Object).Count -gt 0) { $recipientDomain } else { @() }
    
    # Log the domains for debugging
    Write-Host -ForegroundColor $processmessagecolor "Using $(($domainsList | Measure-Object).Count) domain(s) for inbound rule"
    
    # Use the consolidated function to manage the inbound rule
    $managedRule = Manage-SpamFilterRule -RuleType "Inbound" `
                                        -PolicyName $inboundPolicyName `
                                        -PolicyExists $bpPolicyExists `
                                        -RuleName $bpRuleName `
                                        -RuleExists $bpRuleExists `
                                        -ExistingRule $bpRule `
                                        -Domains $domainsList `
                                        -ShouldCreate $createPolicy `
                                        -AutoApply $autoApply
                                        
    # Update the rule reference if a new one was created
    if ($managedRule -and -not $bpRuleExists) {
        $bpRule = $managedRule
        $bpRuleExists = $true
        Write-Host -ForegroundColor $processmessagecolor "Successfully created/updated Best Practices inbound spam rule"
    }
    # Display rule information if we have one
    if ($bpRuleExists) {
        # Display information about the rule
        Write-Host -ForegroundColor Gray -BackgroundColor Blue "Inbound Spam Rule name = ", $bpRule.name
        Write-Host -ForegroundColor $processmessagecolor "   Rule attached Spam Policy =", $bpRule.hostedcontentfilterpolicy
        Write-Host -ForegroundColor $processmessagecolor "   Protected domains = "
        if (-not (IsCollectionEmpty $bpRule.recipientdomainis)) {
            foreach ($item in $bpRule.recipientdomainis) {
                Write-Host -ForegroundColor Gray "        - ", $item
            }
        }
        else {
            Write-Host -ForegroundColor Gray "        None specified"
        }
    }
    else {
        Write-Host -ForegroundColor $warningmessagecolor "No Best Practice inbound spam rule found."
        
        # If we have a Best Practices policy but no rule exists and we didn't manage to create one
        if ($bpPolicyExists -and $createPolicy) {
            Write-Host -ForegroundColor $errormessagecolor "Could not create rule for Best Practices inbound spam policy."
        }
    }
}
catch {
    Write-Host -ForegroundColor $errormessagecolor "Error retrieving inbound spam rules: $($_.Exception.Message)"
}

# Get outbound spam best practices from custom API
Write-Host -ForegroundColor $processmessagecolor "[Info] = Reading Outbound Best Practices from API"
try {
    # Using the same custom API endpoint as the original script
    $query = Invoke-WebRequest -Method GET -ContentType "application/json" -Uri "https://ciaopsgraph.azurewebsites.net/api/f9833ef6b5db63746a2322e085c39eff?id=d8c1da93a449454d6f88ddcbca55e167" -UseBasicParsing -ErrorAction Stop
    $outboundSpamBestPractices = $query.Content | ConvertFrom-Json
    
    # Save the policy name from the API response
    $outboundPolicyName = $outboundSpamBestPractices.identity
    if ([string]::IsNullOrEmpty($outboundPolicyName)) {
        $outboundPolicyName = "Best Practices Outbound Spam Policy"
    }
    
    Write-Host -ForegroundColor $processmessagecolor "Successfully retrieved outbound best practices from API"
}
catch {
    $continue = HandleError -ErrorMessage "Failed to retrieve outbound best practices from API: $($_.Exception.Message)" -ErrorCode "API002" -ExitScript $false
    if (-not $continue) { return }
    
    Write-Host -ForegroundColor $processmessagecolor "Using default outbound best practice values instead"
    
    # Create default values to allow script to continue
    $outboundSpamBestPractices = [PSCustomObject]@{
        identity = "Best Practices Outbound Spam Policy"
        AutoForwardingMode = "On"
        bccsuspiciousoutboundmail = $true
        notifyoutboundspam = $true
        recipientlimitexternalperhour = 500
        recipientlimitinternalperhour = 1000
        recipientlimitperday = 1000
        ActionWhenThresholdReached = "BlockUser"
    }
    
    $outboundPolicyName = $outboundSpamBestPractices.identity
}

# Get outbound spam policies
try {
    Write-Host -ForegroundColor $warningmessagecolor -BackgroundColor DarkGreen "Check for existing Outbound Spam policies"
    $policyparams = Get-HostedOutboundSpamFilterPolicy -ErrorAction Stop
    Write-Host -ForegroundColor $processmessagecolor "Total number of outbound spam policies = ", ($policyparams | Measure-Object).Count
    
    # Check if a Best Practices outbound policy exists
    $bpOutboundPolicyExists = $false
    $bpOutboundPolicy = $null
    
    foreach ($policy in $policyparams) {
        if ($policy.Identity -eq $outboundPolicyName) {
            $bpOutboundPolicyExists = $true
            $bpOutboundPolicy = $policy
            Write-Host -ForegroundColor $processmessagecolor "Found Best Practices outbound spam policy: $($policy.Identity)"
            break
        }
    }
    
    # Create the Best Practices policy if it doesn't exist and creation is enabled
    if (-not $bpOutboundPolicyExists -and $createPolicy) {
        Write-Host -ForegroundColor $processmessagecolor "Creating new Best Practices outbound spam filter policy: $outboundPolicyName"
        
        $policyParams = @{
            'Name' = $outboundPolicyName
            'AutoForwardingMode' = $outboundSpamBestPractices.AutoForwardingMode
            'BccSuspiciousOutboundAdditionalRecipients' = $notifyUsers
            'BccSuspiciousOutboundMail' = $outboundSpamBestPractices.bccsuspiciousoutboundmail
            'NotifyOutboundSpam' = $outboundSpamBestPractices.notifyoutboundspam
            'NotifyOutboundSpamRecipients' = $notifyUsers
            'RecipientLimitExternalPerHour' = $outboundSpamBestPractices.RecipientLimitExternalPerHour
            'RecipientLimitInternalPerHour' = $outboundSpamBestPractices.RecipientLimitInternalPerHour
            'RecipientLimitPerDay' = $outboundSpamBestPractices.RecipientLimitPerDay
            'ActionWhenThresholdReached' = $outboundSpamBestPractices.ActionWhenThresholdReached
        }
        
        try {
            $newPolicy = New-HostedOutboundSpamFilterPolicy @policyParams -ErrorAction Stop
            Write-Host -ForegroundColor $processmessagecolor "Successfully created new Best Practices outbound spam policy: $($newPolicy.Identity)"
            $bpOutboundPolicy = $newPolicy
            $bpOutboundPolicyExists = $true
        }
        catch {
            Write-Host -ForegroundColor $errormessagecolor "Error creating new Best Practices outbound spam policy: $($_.Exception.Message)"
        }
    }
    
    # Determine which policies to check/update
    $outboundPoliciesToCheck = @()
    if ($bpOutboundPolicyExists) {
        $outboundPoliciesToCheck += $bpOutboundPolicy
    } else {
        $outboundPoliciesToCheck = $policyparams
    }
    
    if ($outboundPoliciesToCheck) {
        foreach ($policyparam in $outboundPoliciesToCheck) {
            try {
                Write-Host -ForegroundColor Gray -BackgroundColor Blue "`nOutbound Spam Policy name = ", $policyparam.identity
                $updateNeeded = $false
                $updateParams = @{}
                
                # BccSuspiciousOutboundAdditionalRecipients
                if (IsCollectionEmpty $policyparam.bccsuspiciousoutboundadditionalrecipients) {
                    Write-Host -ForegroundColor $errormessagecolor "   [FAIL] BCC suspicious outbound additional recipients is empty", $fail
                    $updateParams.Add("BccSuspiciousOutboundAdditionalRecipients", $notifyUsers)
                    $updateNeeded = $true
                }
                else {
                    Write-Host -ForegroundColor $processmessagecolor "   [PASS] BCC suspicious outbound additional recipients list is not empty", $pass
                    Write-Host -ForegroundColor Gray "   BCC suspicious outbound additional recipients list is:"
                    foreach ($email in $policyparam.bccsuspiciousoutboundadditionalrecipients) {
                        Write-Host -ForegroundColor Gray "        - ", $email
                    }
                }
                
                # BccSuspiciousOutboundMail
                if ($policyparam.bccsuspiciousoutboundmail -ne $outboundSpamBestPractices.bccsuspiciousoutboundmail) {
                    Write-Host -ForegroundColor $errormessagecolor "   [FAIL] BCC suspicious outbound email disabled", $fail
                    $updateParams.Add("BccSuspiciousOutboundMail", $outboundSpamBestPractices.bccsuspiciousoutboundmail)
                    $updateNeeded = $true
                }
                else {
                    Write-Host -ForegroundColor $processmessagecolor "   [PASS] BCC suspicious outbound email enabled", $pass
                }
                
                # NotifyOutboundSpam
                if ($policyparam.notifyoutboundspam -ne $outboundSpamBestPractices.notifyoutboundspam) {
                    Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Notify outbound spam disabled", $fail
                    $updateParams.Add("NotifyOutboundSpam", $outboundSpamBestPractices.notifyoutboundspam)
                    $updateNeeded = $true
                }
                else {
                    Write-Host -ForegroundColor $processmessagecolor "   [PASS] Notify outbound spam enabled", $pass
                }
                
                # NotifyOutboundSpamRecipients
                if (IsCollectionEmpty $policyparam.NotifyOutboundSpamRecipients) {
                    Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Notify outbound spam recipients is empty", $fail
                    $updateParams.Add("NotifyOutboundSpamRecipients", $notifyUsers)
                    $updateNeeded = $true
                }
                else {
                    Write-Host -ForegroundColor $processmessagecolor "   [PASS] Notify outbound spam recipients list is not empty", $pass
                    Write-Host -ForegroundColor Gray "   Notify outbound spam recipient list is:"
                    foreach ($email in $policyparam.NotifyOutboundSpamRecipients) {
                        Write-Host -ForegroundColor Gray "        - ", $email
                    }
                }
                
                # RecipientLimitExternalPerHour
                if ($policyparam.recipientlimitexternalperhour -lt $outboundSpamBestPractices.recipientlimitexternalperhour) {
                    Write-Host -ForegroundColor $errormessagecolor "   [FAIL] External hourly Recipient Limit =", $policyparam.recipientlimitexternalperhour, $fail
                    $updateParams.Add("RecipientLimitExternalPerHour", $outboundSpamBestPractices.recipientlimitexternalperhour)
                    $updateNeeded = $true
                }
                else {
                    Write-Host -ForegroundColor $processmessagecolor "   [PASS] External hourly Recipient Limit =", $policyparam.recipientlimitexternalperhour, $pass
                }
                
                # RecipientLimitInternalPerHour
                if ($policyparam.recipientlimitinternalperhour -lt $outboundSpamBestPractices.recipientlimitinternalperhour) {
                    Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Internal hourly Recipient Limit =", $policyparam.recipientlimitinternalperhour, $fail
                    $updateParams.Add("RecipientLimitInternalPerHour", $outboundSpamBestPractices.recipientlimitinternalperhour)
                    $updateNeeded = $true
                }
                else {
                    Write-Host -ForegroundColor $processmessagecolor "   [PASS] Internal hourly Recipient Limit =", $policyparam.recipientlimitinternalperhour, $pass
                }
                
                # RecipientLimitPerDay
                if ($policyparam.recipientlimitperday -lt $outboundSpamBestPractices.recipientlimitperday) {
                    Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Recipient Limit per day =", $policyparam.recipientlimitperday, $fail
                    $updateParams.Add("RecipientLimitPerDay", $outboundSpamBestPractices.recipientlimitperday)
                    $updateNeeded = $true
                }
                else {
                    Write-Host -ForegroundColor $processmessagecolor "   [PASS] Recipient Limit per day =", $policyparam.recipientlimitperday, $pass
                }
                
                # ActionWhenThresholdReached
                if ($policyparam.ActionWhenThresholdReached -ne $outboundSpamBestPractices.ActionWhenThresholdReached) {
                    Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Action to take over threshold =", $policyparam.ActionWhenThresholdReached, $fail
                    $updateParams.Add("ActionWhenThresholdReached", $outboundSpamBestPractices.ActionWhenThresholdReached)
                    $updateNeeded = $true
                }
                else {
                    Write-Host -ForegroundColor $processmessagecolor "   [PASS] Action to take over threshold =", $policyparam.ActionWhenThresholdReached, $pass
                }
                
                # Apply updates if needed and auto-apply is enabled
                if ($updateNeeded -and $autoApply) {
                    try {
                        Write-Host -ForegroundColor $processmessagecolor "`n   Applying best practice settings to outbound policy '$($policyparam.Identity)'..."
                        $updateParams.Add("Identity", $policyparam.Identity)
                        
                        # Execute the Set-HostedOutboundSpamFilterPolicy command with our parameters
                        Set-HostedOutboundSpamFilterPolicy @updateParams -ErrorAction Stop
                        
                        Write-Host -ForegroundColor $processmessagecolor "   Changes applied successfully to outbound policy '$($policyparam.Identity)'."
                    }
                    catch {
                        Write-Host -ForegroundColor $errormessagecolor "   [ERROR] Failed to update outbound policy '$($policyparam.Identity)': $($_.Exception.Message)"
                    }
                }
                elseif ($updateNeeded -and -not $autoApply) {
                    Write-Host -ForegroundColor $warningmessagecolor "`n   Changes required for outbound policy '$($policyparam.Identity)' but auto-apply is disabled."
                }
                else {
                    Write-Host -ForegroundColor $processmessagecolor "`n   No changes needed for outbound policy '$($policyparam.Identity)'."
                }
            }
            catch {
                Write-Host -ForegroundColor $errormessagecolor "   [ERROR] Error processing outbound policy '$($policyparam.identity)': $($_.Exception.Message)"
                continue
            }
        }
    }
    else {
        Write-Host -ForegroundColor $warningmessagecolor "No outbound spam policies found."
    }
}
catch {
    Write-Host -ForegroundColor $errormessagecolor "Error retrieving outbound spam policies: $($_.Exception.Message)"
}

# Get outbound spam rules using consolidated function
try {
    Write-Host -ForegroundColor $warningmessagecolor -BackgroundColor DarkGreen "`nCheck for existing Outbound Spam rules"
    $ruleparams = Get-HostedOutboundSpamFilterRule -ErrorAction Stop
    Write-Host -ForegroundColor $processmessagecolor "Total number of outbound rules = ", ($ruleparams | Measure-Object).Count
    
    # Define our Best Practice outbound rule name
    $bpOutboundRuleName = "Best Practices Outbound Spam Rule"
    $bpOutboundRuleExists = $false
    $bpOutboundRule = $null
    
    if ($ruleparams) {
        # First check if we have a rule for the Best Practices policy
        foreach ($rule in $ruleparams) {
            if (($rule.Name -eq $bpOutboundRuleName) -or ($rule.HostedOutboundSpamFilterPolicy -eq $outboundPolicyName)) {
                $bpOutboundRuleExists = $true
                $bpOutboundRule = $rule
                Write-Host -ForegroundColor $processmessagecolor "Found rule for Best Practices outbound policy: $($rule.Name)"
                break
            }
        }
    }
    
    # Use the consolidated function to manage the outbound rule
    # Make sure we have domains to work with
    $domainIds = if ($domains -and ($domains | Measure-Object).Count -gt 0) { $domains.Id } else { @() }
    
    # Log the domains for debugging
    Write-Host -ForegroundColor $processmessagecolor "Using $(($domainIds | Measure-Object).Count) domain(s) for outbound rule"
    
    $managedOutboundRule = Manage-SpamFilterRule -RuleType "Outbound" `
                                       -PolicyName $outboundPolicyName `
                                       -PolicyExists $bpOutboundPolicyExists `
                                       -RuleName $bpOutboundRuleName `
                                       -RuleExists $bpOutboundRuleExists `
                                       -ExistingRule $bpOutboundRule `
                                       -Domains $domainIds `
                                       -ShouldCreate $createPolicy `
                                       -AutoApply $autoApply
                                      
    # Update the rule reference if a new one was created
    if ($managedOutboundRule -and -not $bpOutboundRuleExists) {
        $bpOutboundRule = $managedOutboundRule
        $bpOutboundRuleExists = $true
        Write-Host -ForegroundColor $processmessagecolor "Successfully created/updated Best Practices outbound spam rule"
    }
    
    # Display rule information if we have one
    if ($bpOutboundRuleExists) {
        # Display information about the rule
        Write-Host -ForegroundColor Gray -BackgroundColor Blue "Outbound Spam Rule name = ", $bpOutboundRule.name
        Write-Host -ForegroundColor $processmessagecolor "   Rule attached Outbound Spam Policy =", $bpOutboundRule.hostedoutboundspamfilterpolicy
        
        Write-Host -ForegroundColor $processmessagecolor "   Sender domains = "
        if (-not (IsCollectionEmpty $bpOutboundRule.senderdomainis)) {
            foreach ($item in $bpOutboundRule.senderdomainis) {
                Write-Host -ForegroundColor Gray "        - ", $item
            }
        }
        else {
            Write-Host -ForegroundColor Gray "        None specified"
        }
        
        # Check additional outbound rule properties
        Write-Host -ForegroundColor $processmessagecolor "   Additional rule properties:"
        
        # ExceptIfFrom
        if (IsCollectionEmpty $bpOutboundRule.exceptiffrom) {    
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Except if from list is empty", $pass
        }
        else {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Except if from list is not empty", $fail
            foreach ($item in $bpOutboundRule.exceptiffrom) {
                Write-Host -ForegroundColor Gray "        - ", $item
            }
        }
        
        # ExceptIfFromMemberOf
        if (IsCollectionEmpty $bpOutboundRule.exceptiffrommemberof) {    
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] Except if from member of list is empty", $pass
        }
        else {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] Except of from member of list is not empty", $fail
            foreach ($item in $bpOutboundRule.exceptiffrommemberof) {
                Write-Host -ForegroundColor Gray "        - ", $item
            }
        }
        
        # From
        if (IsCollectionEmpty $bpOutboundRule.from) {    
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] From list is empty", $pass
        }
        else {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] From list is not empty", $fail
            foreach ($item in $bpOutboundRule.from) {
                Write-Host -ForegroundColor Gray "        - ", $item
            }
        }
        
        # FromMemberOf
        if (IsCollectionEmpty $bpOutboundRule.frommemberof) {    
            Write-Host -ForegroundColor $processmessagecolor "   [PASS] From member of list is empty", $pass
        }
        else {
            Write-Host -ForegroundColor $errormessagecolor "   [FAIL] From member of list is not empty", $fail
            foreach ($item in $bpOutboundRule.frommemberof) {
                Write-Host -ForegroundColor Gray "        - ", $item
            }
        }
    }
    else {
        Write-Host -ForegroundColor $warningmessagecolor "No Best Practice outbound spam rule found."
        
        # Check if we have a default policy
        $outboundFilterPolicy = Get-HostedOutboundSpamFilterPolicy -Identity $outboundPolicyName -ErrorAction SilentlyContinue
        if ($outboundFilterPolicy -and $outboundFilterPolicy.IsDefault) {
            Write-Host -ForegroundColor $processmessagecolor "Policy '$outboundPolicyName' is the default policy - no rule needed"
        }
        # If we have a Best Practices policy but no rule exists and we didn't manage to create one
        elseif ($bpOutboundPolicyExists -and $createPolicy) {
            Write-Host -ForegroundColor $errormessagecolor "Could not create rule for Best Practices outbound spam policy."
        }
    }
}
catch {
    Write-Host -ForegroundColor $errormessagecolor "Error retrieving outbound spam rules: $($_.Exception.Message)"
}

# Clean up connections
try {
    Disconnect-MgGraph -ErrorAction SilentlyContinue | Out-Null
    Write-Host -ForegroundColor $processmessagecolor "Disconnected from Microsoft Graph"
} catch {
    # Ignore any errors disconnecting
}

# Create a comprehensive summary of actions taken
$summary = @{
    InboundPolicyCreated = $false
    InboundPolicyUpdated = $false
    InboundRuleCreated = $false
    OutboundPolicyCreated = $false
    OutboundPolicyUpdated = $false
    OutboundRuleCreated = $false
    QuarantinePolicyCreated = $false
    TotalDomains = 0
    NotificationEmails = @()
}

# Update summary
if ($bpPolicyExists -and -not (Get-HostedContentFilterPolicy -Identity $inboundPolicyName -ErrorAction SilentlyContinue)) {
    $summary.InboundPolicyCreated = $true
}

if ($bpRuleExists -and -not (Get-HostedContentFilterRule -Identity $bpRuleName -ErrorAction SilentlyContinue)) {
    $summary.InboundRuleCreated = $true
}

if ($bpOutboundPolicyExists -and -not (Get-HostedOutboundSpamFilterPolicy -Identity $outboundPolicyName -ErrorAction SilentlyContinue)) {
    $summary.OutboundPolicyCreated = $true
}

if ($bpOutboundRuleExists -and -not (Get-HostedOutboundSpamFilterRule -Identity $bpOutboundRuleName -ErrorAction SilentlyContinue)) {
    $summary.OutboundRuleCreated = $true
}

$summary.TotalDomains = if ($domains) { ($domains | Measure-Object).Count } else { 0 }
$summary.NotificationEmails = $notifyUsers

# Script conclusion header
Write-Host -ForegroundColor $systemmessagecolor "`n======================================================"
Write-Host -ForegroundColor $systemmessagecolor "         MICROSOFT 365 SPAM POLICY SUMMARY"
Write-Host -ForegroundColor $systemmessagecolor "======================================================"

# Policy Status
Write-Host -ForegroundColor $warningmessagecolor "`nPOLICY STATUS:"

if ($createPolicy) {
    if ($autoApply) {
        Write-Host -ForegroundColor $processmessagecolor "- Mode: Full Create & Update"
        Write-Host -ForegroundColor $processmessagecolor "  Created Best Practice policies as needed and updated all policies to comply with best practices."
    } else {
        Write-Host -ForegroundColor $processmessagecolor "- Mode: Creation Only (Reports Only)"
        Write-Host -ForegroundColor $processmessagecolor "  Created Best Practice policies as needed, but no updates were applied (auto-apply disabled)."
    }
} else {
    if ($autoApply) {
        Write-Host -ForegroundColor $processmessagecolor "- Mode: Update Only"
        Write-Host -ForegroundColor $processmessagecolor "  All policies checked and updated where needed to comply with best practices."
    } else {
        Write-Host -ForegroundColor $processmessagecolor "- Mode: Report Only"
        Write-Host -ForegroundColor $processmessagecolor "  No changes applied - only reported deviations from best practices."
    }
}

# Inbound Policy Details
Write-Host -ForegroundColor $warningmessagecolor "`nINBOUND SPAM FILTERING:"
if ($bpPolicyExists) {
    Write-Host -ForegroundColor $processmessagecolor "- Best Practice Inbound Policy: " -NoNewline
    Write-Host -ForegroundColor Gray "Exists ($inboundPolicyName)"
    
    if ($summary.InboundPolicyCreated) {
        Write-Host -ForegroundColor $processmessagecolor "  [CREATED] New policy created during this session"
    }
} else {
    Write-Host -ForegroundColor $errormessagecolor "- Best Practice Inbound Policy: " -NoNewline
    Write-Host -ForegroundColor Gray "Not Found"
}

if ($bpRuleExists) {
    Write-Host -ForegroundColor $processmessagecolor "- Best Practice Inbound Rule: " -NoNewline
    Write-Host -ForegroundColor Gray "Exists ($bpRuleName)"
    
    if ($summary.InboundRuleCreated) {
        Write-Host -ForegroundColor $processmessagecolor "  [CREATED] New rule created during this session"
    }
} else {
    if ($bpPolicyExists) {
        Write-Host -ForegroundColor $errormessagecolor "- Best Practice Inbound Rule: " -NoNewline
        Write-Host -ForegroundColor Gray "Not Found (Required for non-default policy)"
    }
}

# Outbound Policy Details
Write-Host -ForegroundColor $warningmessagecolor "`nOUTBOUND SPAM FILTERING:"
if ($bpOutboundPolicyExists) {
    Write-Host -ForegroundColor $processmessagecolor "- Best Practice Outbound Policy: " -NoNewline
    Write-Host -ForegroundColor Gray "Exists ($outboundPolicyName)"
    
    if ($summary.OutboundPolicyCreated) {
        Write-Host -ForegroundColor $processmessagecolor "  [CREATED] New policy created during this session"
    }
    
    # Check if it's default
    $outboundFilterPolicy = Get-HostedOutboundSpamFilterPolicy -Identity $outboundPolicyName -ErrorAction SilentlyContinue
    if ($outboundFilterPolicy -and $outboundFilterPolicy.IsDefault) {
        Write-Host -ForegroundColor $processmessagecolor "  [NOTE] This is the default policy (rule not required)"
    }
} else {
    Write-Host -ForegroundColor $errormessagecolor "- Best Practice Outbound Policy: " -NoNewline
    Write-Host -ForegroundColor Gray "Not Found"
}

if ($bpOutboundRuleExists) {
    Write-Host -ForegroundColor $processmessagecolor "- Best Practice Outbound Rule: " -NoNewline
    Write-Host -ForegroundColor Gray "Exists ($bpOutboundRuleName)"
    
    if ($summary.OutboundRuleCreated) {
        Write-Host -ForegroundColor $processmessagecolor "  [CREATED] New rule created during this session"
    }
} else {
    # Only show as an issue if outbound policy exists and isn't default
    $outboundFilterPolicy = Get-HostedOutboundSpamFilterPolicy -Identity $outboundPolicyName -ErrorAction SilentlyContinue
    if ($bpOutboundPolicyExists -and (-not $outboundFilterPolicy -or -not $outboundFilterPolicy.IsDefault)) {
        Write-Host -ForegroundColor $errormessagecolor "- Best Practice Outbound Rule: " -NoNewline
        Write-Host -ForegroundColor Gray "Not Found (Required for non-default policy)"
    }
}

# Add a delay to allow policies to propagate if they were created in this session
if ($quarantinePolicyCreated -or $malwarePolicyCreated) {
    Write-Host -ForegroundColor $processmessagecolor "`nWaiting for policies to propagate (5 seconds)..."
    Start-Sleep -Seconds 5
}

# Quarantine Policy
Write-Host -ForegroundColor $warningmessagecolor "`nQUARANTINE POLICY:"
$quarpolicies = Get-QuarantinePolicy -ErrorAction SilentlyContinue
$bpQuarFound = $false

# More flexible pattern matching for quarantine policies
$quarPatterns = @(
    'BP - Quarantine', 
    'Best Practice.*Quarantine', 
    'Quarantine.*BP',
    'Quarantine.*Best Practice'
)

if ($quarpolicies) {
    foreach ($policy in $quarpolicies) {
        $policyNameMatched = $false
        
        # Case-insensitive matching against multiple patterns
        foreach ($pattern in $quarPatterns) {
            if ($policy.Name -match "(?i)$pattern") {
                $policyNameMatched = $true
                break
            }
        }
        
        if ($policyNameMatched) {
            $bpQuarFound = $true
            Write-Host -ForegroundColor $processmessagecolor "- Best Practice Quarantine Policy: " -NoNewline
            Write-Host -ForegroundColor Gray "Exists ($($policy.Name))"
            break
        }
    }
}

if (-not $bpQuarFound) {
    Write-Host -ForegroundColor $errormessagecolor "- Best Practice Quarantine Policy: " -NoNewline
    if ($quarantinePolicyCreated) {
        Write-Host -ForegroundColor Gray "Created during this session but not yet visible in PowerShell"
        Write-Host -ForegroundColor $processmessagecolor "  [NOTE] Verify in the Microsoft 365 Admin Center"
    } else {
        Write-Host -ForegroundColor Gray "Not Found"
    }
}

# Malware Policy
Write-Host -ForegroundColor $warningmessagecolor "`nMALWARE POLICY:"
# Try second time after delay for better results
$malwarePolicies = Get-MalwareFilterPolicy -ErrorAction SilentlyContinue
$bpMalwareFound = $false

# More flexible pattern matching for malware policies
$malwarePatterns = @(
    'BP - Malware', 
    'Best Practice.*Malware', 
    'Malware.*BP',
    'Malware.*Best Practice'
)

if ($malwarePolicies) {
    foreach ($policy in $malwarePolicies) {
        $policyNameMatched = $false
        
        # Case-insensitive matching against multiple patterns
        foreach ($pattern in $malwarePatterns) {
            if ($policy.Name -match "(?i)$pattern") {
                $policyNameMatched = $true
                break
            }
        }
        
        if ($policyNameMatched) {
            $bpMalwareFound = $true
            Write-Host -ForegroundColor $processmessagecolor "- Best Practice Malware Policy: " -NoNewline
            Write-Host -ForegroundColor Gray "Exists ($($policy.Name))"
            break
        }
    }
}

if (-not $bpMalwareFound) {
    Write-Host -ForegroundColor $errormessagecolor "- Best Practice Malware Policy: " -NoNewline
    if ($malwarePolicyCreated) {
        Write-Host -ForegroundColor Gray "Created during this session but not yet visible in PowerShell"
        Write-Host -ForegroundColor $processmessagecolor "  [NOTE] Verify in the Microsoft 365 Admin Center"
    } else {
        Write-Host -ForegroundColor Gray "Not Found"
    }
}

# Protection Statistics
Write-Host -ForegroundColor $warningmessagecolor "`nPROTECTION COVERAGE:"
Write-Host -ForegroundColor $processmessagecolor "- Protected Domains: " -NoNewline
Write-Host -ForegroundColor Gray "$($summary.TotalDomains) domains"

# Notification emails
if (-not (IsCollectionEmpty $notifyUsers)) {
    Write-Host -ForegroundColor $warningmessagecolor "`nNOTIFICATION RECIPIENTS:"
    foreach ($user in $notifyUsers) {
        Write-Host -ForegroundColor $processmessagecolor "- $user"
    }
}

# End of report
Write-Host -ForegroundColor $systemmessagecolor "`n======================================================"
Write-Host -ForegroundColor $systemmessagecolor "          END OF SPAM POLICY REPORT"
Write-Host -ForegroundColor $systemmessagecolor "======================================================"

Write-Host -ForegroundColor $processmessagecolor "`nPress any key to exit..."
$host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown") | Out-Null

# Stop transcript if it was started
if ($debug) {
    try {
        Stop-Transcript -ErrorAction SilentlyContinue
    }
    catch {
        # Ignore errors stopping transcript
    }
}

<# Reference information
Language list
    AF - Afrikaans
    SQ - Albanian
    AR - Arabic
    HY - Armenian
    AZ - Azerbaijani
    BN - Bangla
    EU - Basque
    BE - Belarusian
    BS - Bosnian
    BR - Breton
    BG - Bulgarian
    CA - Catalan
    ZH-CN - Chinese (Simlified, China)
    ZH-TW - Chinese (traditional, Taiwan)
    HR - Croatian
    CS - Czech
    DA - Danish
    NL - Dutch
    EN - English
    EO - Esperanto
    ET - Estonian
    FO - Faroese
    TL - Filipino
    FI - Finnish
    FR - French
    FY - Frisian
    GL - Galician
    KA - Georgian
    DE - German
    El - Greek
    KL - Greenlandic
    GU - Gujarati
    HA - Hausa
    HE - Hebrew
    HI - Hindi
    HU - Hungarian
    IS - Icelandic
    ID - Indonesian
    GA - Irish
    ZU - isi Zulu
    IT - Italian
    JA - Japanese
    KN - Kannada
    KK - Kazakh
    SW - Kiswahili
    KO - Korean
    KU - Kurdish
    KY - Kyrgyz
    LA - Latin
    LV - Latvian
    LT - Lthuanian
    LB - Luxrmbourgish
    MK - Macedonian (FYROM)
    MS - Malay
    ML - Malayalam
    MT - Maltese
    MI - Maori
    MN - Mongolian
    NB - Norwegian (Bokmal)
    NN - Norwegian (Nynorsk)
    PS - Pashto
    FA - Persian
    PL - Polich
    PT - Protuguese
    PA - Punjabi
    RO - Romanian
    RM - Romansh
    RU - Russian
    SE - Sami (Northern)
    SR - Serbian
    SK - Slovak
    SL - Slovenian
    WEN - Sorbian
    ES - Spanish
    SV - Swedish
    TA - Tamil
    TE - Telugu
    TH - Thai
    TR - Turkish
    UK - Ukranian
    UR - Urdu
    UZ - Uzbek
    VI - Vietnamese
    CY - Welsh
    YI - Yiddish

Country list
    AF - Afghanistan
    AX - Aland Islands
    AL - Albania
    DZ - Algeria
    AS - American Samoa
    AD - Andorra
    AO - Angola
    AI - Anguilla
    AQ - Antarctica
    AG - Antigua and Barbuda
    AR - Agentina
    AM - Armenia
    AW - Aruba
    AU - Australia
    AT - Austria
    AZ - Azerbaijan
    BS - Bahamas
    BH - Bahrain
    BD - Bangladesh
    BB - Barbados
    BY - Belarus
    BE - Belgium
    BZ - Belize
    BJ - Benin
    BM - bermuda
    BT - Bhutan
    BO - Bolivia
    BQ - Bonaire, Saint Eustatius and Saba
    BA - Bosnia and Herzegovina
    BW - Botswana
    BV - Bouvet Island
    BR - Brazil
    IO - British Indian Ocean Territory
    VG - British Virgin Islands
    BN - Brunei
    BG - Bulgaria
    BF - Burkina Faso
    BI - Burundi
    CV - Cabo Verde
    KH - Cambodia
    CM - Cameroon
    CA - Canada
    KY - Cayman Islands
    CF - Central African Republic
    TD - Chad
    CL - Chile
    CN - China
    CX - Christmas Island
    CC - Cocos (Keeling) Islands
    CO - Colombia
    KM - Comoros
    CG - Congo
    CD - Congo (DRC)
    CK - Cook Islands
    CR - Costa Rica
    CO - Cote dvoire
    HR - Croatia
    CU - Cuba
    CW - Curacao
    CY - Cyprus
    CZ - Czech Republic
    Dk - Denmark
    DJ - Djibouti
    DM - Dominica
    DO - Dominican Republic
    EC - Ecuador
    EG - Egypt
    SV - El Salvador
    GQ - Equatorial Guinea
    ER - Eritrea
    EE - Estonian
    ET - Ethopia
    FK - Falkland Islands (Islas Malvinas)
    FO - Faroe Islands
    FJ - Fiji
    FI - Finland
    FR - France
    GF - French Guiana
    PF - French Polynesia
    TF - French Souther and Antarctic Lands
    GA - Gabon
    GM - Gambia
    GE - Georgia
    DE - Germany
    GH - Ghana
    GI - Gilbraltar
    GR - Greece
    GL - Greenland
    GD - Grenada
    GP - Guadeloupe
    GU - Guam
    GT - Guatemala
    GG - Guernsey
    GN - Guinea
    GW - Guinea-Bissau
    GY - Guyana
    HT - Haiti
    HM - Heard Island and McDonald Islands
    VA - Holy See (vatican City)
    HN - Honduras
    HK - Hong Kong SAR
    HU - Hungary
    IS - Iceland
    IN - India
    ID - Indonesia
    IR - Iran
    IQ - Iraq
    IE - Ireland
    IM - isel of Man
    IL - Israel
    IT - Italy
    JM - Jamica
    XJ - Jan Mayen
    SJ - Jay Mayen
    JP - Japan
    JE - Jersey
    JO - Jordan
    KZ - Kazakhstan
    KE - Kenya
    KI - Kiribati
    KR - Korea
    KW - Kuwait
    KG - Kyrgyzstan
    LA - Laos
    LV - Latvia
    LB - Lebanon
    LS - Lesotho
    LR - Liberia
    LY - Libya
    LI - Liechtenstein
    LT - Lithuania
    LU - Luxembourg
    MK - Macedonia, Former Yugoslav Replubic of
    MG - Madagascar
    MY - Malaysia
    MV - Maldives
    ML - Mali
    MT - Malta
    MH - Marshall Islands
    MQ - Martinique
    MR - Mauritania
    MU - Mauritius
    YT - Mayotte
    MX - Mexico
    FM - Micronesia
    MD - Moldova
    MC - Monaco
    MZ - Mozambique
    MM - Myanmar
    NA - Namibia
    NR - Naru
    NP - Nepal
    NL - Netherlands
    NC - New Caledonia
    NZ - New Zealand
    NI - Nicaragua
    NE - Niger
    NU - Niue
    NF - Norfolk Island
    KP - North Korea
    MP - Nothern Mariana Islands
    NO - Norway
    OM - Oman
    PK - Pakistan
    PW - Palau
    PS - Palastinian Authority
    PA - Panama
    PG - Papua New Guinea
    PY - Paraguay
    PE - Peru
    PH - Philippines
    PN - Pitcairn Islands
    PL - Poland
    PT - Portugal
    PR - Puerto Rico
    QA - Qatar
    RE - Reunion
    RO - Romania
    RU - Russian
    RW - Rwanda
    XS - Saba, Public, Body of Saba
    BL - Saint Barthelemy
    KN - Saint Kitts and Nevis
    LC - Saint Lucia
    MF - Saint Martin
    PM - Saint Pierre and Miquelon
    VC - Saint Vincent and the Grenadines
    WS - Samoa
    SM - San Marino
    ST - Sao Tome and Principe
    SA - Saudi Arabia
    SN - Senegal
    RS - Serbia
    SC - Seychelles
    SL - Sierra Leone
    SG - Singapore
    XE - Sint Eustatius, Public body of Sint Eustatius
    SX - Sint Maarten
    SI - Slovenia
    SB - Solomon Islands
    SO - Somalia
    ZA - South Africa
    GS - South Georgia and the South Sanwich Islands
    ES - Spain
    LK - Sri Lanka
    SH - St Helena, Ascension, Tristan de Cunha
    SD - Sudan
    SR - Suriname
    SZ - Swaziland
    SE - Sweden
    CH - Switzerland
    SY - Syria
    TW - Taiwan
    TJ - Tajikistan
    TZ - Tanzania
    TH - Thailand
    TL - Timor-Leste
    TG - Togo
    TK - Tokelau
    TO - Tonga
    TT - Trinidad and Tobago
    TN - Tunisia
    TR - Turkey
    TM - Turkmenistan
    TC - Turks and Caicos Islands
    TV - Tuvalu
    UM - U.S. Minor Outlying Islands
    VI - U.S. Virgin Islands
    UG - Uganda
    UA - Ukraine
    AE - United Arab Emirates
    GB - United Kingdom
    US - United States
    UY - Uruguay
    UZ - Uzbekistan
    VU - Vanuatu
    VE - Venzuela
    VN - Vietnam
    WF - Wallis and Futuna
    Ye - Yemen
    ZM - Zambia
    ZE - Zimbabwe
#>